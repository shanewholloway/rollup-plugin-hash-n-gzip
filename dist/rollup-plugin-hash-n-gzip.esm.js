import { basename, format, parse } from 'path';
import { promisify } from 'util';
import { createHash } from 'crypto';
import { createGzip } from 'zlib';
import { copyFile, createReadStream, createWriteStream, stat, writeFile } from 'fs';

const p_stat = promisify(stat);
const p_copyFile = promisify(copyFile);
const p_writeFile = promisify(writeFile);

hash_n_gzip.hashFile = hashFile;
hash_n_gzip.compressFile = compressFile;
function hash_n_gzip({ minSize, hash_algorithm } = {}) {
  return {
    name: 'hash-n-gzip',
    async onwrite(buildOpts) {
      const file = buildOpts.file;
      const gzfile = `${file}.gz`;
      const [h, compressed] = await Promise.all([hashFile(file, hash_algorithm), compressFile(file, gzfile, minSize)]);

      const fname_parts = parse(file);
      fname_parts.base = null;
      fname_parts.ext = `.${h}${fname_parts.ext}`;

      const dest_hash = format(fname_parts);
      await Promise.all([p_copyFile(file, dest_hash), compressed && p_copyFile(gzfile, `${dest_hash}.gz`)]);
      await p_writeFile(`${file}.lnk`, basename(dest_hash));
    } };
}

function hashFile(file, algorithm) {
  if (!algorithm) {
    algorithm = 'sha1';
  }
  return new Promise(function (resolve, reject) {
    createReadStream(file).pipe(createHash(algorithm)).on('error', reject).on('data', function (h) {
      resolve(h.toString('hex'));
    });
  });
}

function compressFile(file, outfile, minSize) {
  if (!outfile) {
    outfile = `${file}.gz`;
  }
  if (!minSize) {
    minSize = 14e3;
  }

  return p_stat(file).then(stat$$1 => {
    if (stat$$1.size <= minSize) {
      return false;
    }
    return new Promise(function (resolve, reject) {
      createReadStream(file).pipe(createGzip()).pipe(createWriteStream(outfile)).on('error', reject).on('finish', () => resolve(true));
    });
  });
}

export default hash_n_gzip;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9sbHVwLXBsdWdpbi1oYXNoLW4tZ3ppcC5lc20uanMiLCJzb3VyY2VzIjpbIi4uL2NvZGUvaW5kZXguanN5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCB7cHJvbWlzaWZ5fSBmcm9tICd1dGlsJ1xuaW1wb3J0IHtjcmVhdGVIYXNofSBmcm9tICdjcnlwdG8nXG5pbXBvcnQge2NyZWF0ZUd6aXB9IGZyb20gJ3psaWInXG5pbXBvcnQge3N0YXQsIGNvcHlGaWxlLCB3cml0ZUZpbGUsIGNyZWF0ZVJlYWRTdHJlYW0sIGNyZWF0ZVdyaXRlU3RyZWFtfSBmcm9tICdmcydcbmNvbnN0IHBfc3RhdCA9IHByb21pc2lmeSBAIHN0YXRcbmNvbnN0IHBfY29weUZpbGUgPSBwcm9taXNpZnkgQCBjb3B5RmlsZVxuY29uc3QgcF93cml0ZUZpbGUgPSBwcm9taXNpZnkgQCB3cml0ZUZpbGVcblxuaGFzaF9uX2d6aXAuaGFzaEZpbGUgPSBoYXNoRmlsZVxuaGFzaF9uX2d6aXAuY29tcHJlc3NGaWxlID0gY29tcHJlc3NGaWxlXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYXNoX25fZ3ppcCh7bWluU2l6ZSwgaGFzaF9hbGdvcml0aG19PXt9KSA6OlxuICByZXR1cm4gQHt9XG4gICAgbmFtZTogJ2hhc2gtbi1nemlwJ1xuICAgIGFzeW5jIG9ud3JpdGUoYnVpbGRPcHRzKSA6OlxuICAgICAgY29uc3QgZmlsZSA9IGJ1aWxkT3B0cy5maWxlXG4gICAgICBjb25zdCBnemZpbGUgPSBgJHtmaWxlfS5nemBcbiAgICAgIGNvbnN0IFtoLCBjb21wcmVzc2VkXSA9IGF3YWl0IFByb21pc2UuYWxsIEAjXG4gICAgICAgIGhhc2hGaWxlIEAgZmlsZSwgaGFzaF9hbGdvcml0aG1cbiAgICAgICAgY29tcHJlc3NGaWxlIEAgZmlsZSwgZ3pmaWxlLCBtaW5TaXplXG5cbiAgICAgIGNvbnN0IGZuYW1lX3BhcnRzID0gcGF0aC5wYXJzZShmaWxlKVxuICAgICAgZm5hbWVfcGFydHMuYmFzZSA9IG51bGxcbiAgICAgIGZuYW1lX3BhcnRzLmV4dCA9IGAuJHtofSR7Zm5hbWVfcGFydHMuZXh0fWBcblxuICAgICAgY29uc3QgZGVzdF9oYXNoID0gcGF0aC5mb3JtYXQoZm5hbWVfcGFydHMpXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCBAI1xuICAgICAgICAgIHBfY29weUZpbGUgQCBmaWxlLCBkZXN0X2hhc2hcbiAgICAgICAgLCBjb21wcmVzc2VkICYmIHBfY29weUZpbGUgQCBnemZpbGUsIGAke2Rlc3RfaGFzaH0uZ3pgXG4gICAgICBhd2FpdCBwX3dyaXRlRmlsZSBAIGAke2ZpbGV9Lmxua2AsIHBhdGguYmFzZW5hbWUoZGVzdF9oYXNoKVxuXG5mdW5jdGlvbiBoYXNoRmlsZShmaWxlLCBhbGdvcml0aG0pIDo6XG4gIGlmICEgYWxnb3JpdGhtIDo6IGFsZ29yaXRobSA9ICdzaGExJ1xuICByZXR1cm4gbmV3IFByb21pc2UgQCBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIDo6XG4gICAgY3JlYXRlUmVhZFN0cmVhbShmaWxlKVxuICAgICAgLnBpcGUgQCBjcmVhdGVIYXNoKGFsZ29yaXRobSlcbiAgICAgIC5vbiBAICdlcnJvcicsIHJlamVjdFxuICAgICAgLm9uIEAgJ2RhdGEnLCBmdW5jdGlvbihoKSA6OlxuICAgICAgICByZXNvbHZlIEAgaC50b1N0cmluZygnaGV4JylcblxuZnVuY3Rpb24gY29tcHJlc3NGaWxlKGZpbGUsIG91dGZpbGUsIG1pblNpemUpIDo6XG4gIGlmICEgb3V0ZmlsZSA6OiBvdXRmaWxlID0gYCR7ZmlsZX0uZ3pgXG4gIGlmICEgbWluU2l6ZSA6OiBtaW5TaXplID0gMTRlM1xuXG4gIHJldHVybiBwX3N0YXQoZmlsZSkudGhlbiBAIHN0YXQgPT4gOjpcbiAgICBpZiBzdGF0LnNpemUgPD0gbWluU2l6ZSA6OiByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gbmV3IFByb21pc2UgQCBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIDo6XG4gICAgICBjcmVhdGVSZWFkU3RyZWFtKGZpbGUpXG4gICAgICAgIC5waXBlIEAgY3JlYXRlR3ppcCgpXG4gICAgICAgIC5waXBlIEAgY3JlYXRlV3JpdGVTdHJlYW0gQCBvdXRmaWxlXG4gICAgICAgIC5vbiBAICdlcnJvcicsIHJlamVjdFxuICAgICAgICAub24gQCAnZmluaXNoJywgKCkgPT4gcmVzb2x2ZSh0cnVlKVxuXG4iXSwibmFtZXMiOlsicF9zdGF0IiwicHJvbWlzaWZ5Iiwic3RhdCIsInBfY29weUZpbGUiLCJjb3B5RmlsZSIsInBfd3JpdGVGaWxlIiwid3JpdGVGaWxlIiwiaGFzaF9uX2d6aXAiLCJoYXNoRmlsZSIsImNvbXByZXNzRmlsZSIsIm1pblNpemUiLCJoYXNoX2FsZ29yaXRobSIsIm9ud3JpdGUiLCJidWlsZE9wdHMiLCJmaWxlIiwiZ3pmaWxlIiwiaCIsImNvbXByZXNzZWQiLCJQcm9taXNlIiwiYWxsIiwiZm5hbWVfcGFydHMiLCJwYXRoIiwiYmFzZSIsImV4dCIsImRlc3RfaGFzaCIsImFsZ29yaXRobSIsInJlc29sdmUiLCJyZWplY3QiLCJwaXBlIiwiY3JlYXRlSGFzaCIsIm9uIiwidG9TdHJpbmciLCJvdXRmaWxlIiwidGhlbiIsInNpemUiLCJjcmVhdGVHemlwIiwiY3JlYXRlV3JpdGVTdHJlYW0iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUtBLE1BQU1BLFNBQVNDLFVBQVlDLElBQVosQ0FBZjtBQUNBLE1BQU1DLGFBQWFGLFVBQVlHLFFBQVosQ0FBbkI7QUFDQSxNQUFNQyxjQUFjSixVQUFZSyxTQUFaLENBQXBCOztBQUVBQyxZQUFZQyxRQUFaLEdBQXVCQSxRQUF2QjtBQUNBRCxZQUFZRSxZQUFaLEdBQTJCQSxZQUEzQjtBQUNBLEFBQWUsU0FBU0YsV0FBVCxDQUFxQixFQUFDRyxPQUFELEVBQVVDLGNBQVYsS0FBMEIsRUFBL0MsRUFBbUQ7U0FDekQ7VUFDQyxhQUREO1VBRUNDLE9BQU4sQ0FBY0MsU0FBZCxFQUF5QjtZQUNqQkMsT0FBT0QsVUFBVUMsSUFBdkI7WUFDTUMsU0FBVSxHQUFFRCxJQUFLLEtBQXZCO1lBQ00sQ0FBQ0UsQ0FBRCxFQUFJQyxVQUFKLElBQWtCLE1BQU1DLFFBQVFDLEdBQVIsQ0FBYyxDQUMxQ1gsU0FBV00sSUFBWCxFQUFpQkgsY0FBakIsQ0FEMEMsRUFFMUNGLGFBQWVLLElBQWYsRUFBcUJDLE1BQXJCLEVBQTZCTCxPQUE3QixDQUYwQyxDQUFkLENBQTlCOztZQUlNVSxjQUFjQyxLQUFBLENBQVdQLElBQVgsQ0FBcEI7a0JBQ1lRLElBQVosR0FBbUIsSUFBbkI7a0JBQ1lDLEdBQVosR0FBbUIsSUFBR1AsQ0FBRSxHQUFFSSxZQUFZRyxHQUFJLEVBQTFDOztZQUVNQyxZQUFZSCxNQUFBLENBQVlELFdBQVosQ0FBbEI7WUFDTUYsUUFBUUMsR0FBUixDQUFjLENBQ2hCaEIsV0FBYVcsSUFBYixFQUFtQlUsU0FBbkIsQ0FEZ0IsRUFFaEJQLGNBQWNkLFdBQWFZLE1BQWIsRUFBc0IsR0FBRVMsU0FBVSxLQUFsQyxDQUZFLENBQWQsQ0FBTjtZQUdNbkIsWUFBZSxHQUFFUyxJQUFLLE1BQXRCLEVBQTZCTyxRQUFBLENBQWNHLFNBQWQsQ0FBN0IsQ0FBTjtLQWpCRyxFQUFQOzs7QUFtQkYsU0FBU2hCLFFBQVQsQ0FBa0JNLElBQWxCLEVBQXdCVyxTQUF4QixFQUFtQztNQUM5QixDQUFFQSxTQUFMLEVBQWlCO2dCQUFhLE1BQVo7O1NBQ1gsSUFBSVAsT0FBSixDQUFjLFVBQVNRLE9BQVQsRUFBa0JDLE1BQWxCLEVBQTBCO3FCQUM1QmIsSUFBakIsRUFDR2MsSUFESCxDQUNVQyxXQUFXSixTQUFYLENBRFYsRUFFR0ssRUFGSCxDQUVRLE9BRlIsRUFFaUJILE1BRmpCLEVBR0dHLEVBSEgsQ0FHUSxNQUhSLEVBR2dCLFVBQVNkLENBQVQsRUFBWTtjQUNkQSxFQUFFZSxRQUFGLENBQVcsS0FBWCxDQUFWO0tBSko7R0FESyxDQUFQOzs7QUFPRixTQUFTdEIsWUFBVCxDQUFzQkssSUFBdEIsRUFBNEJrQixPQUE1QixFQUFxQ3RCLE9BQXJDLEVBQThDO01BQ3pDLENBQUVzQixPQUFMLEVBQWU7Y0FBWSxHQUFFbEIsSUFBSyxLQUFsQjs7TUFDYixDQUFFSixPQUFMLEVBQWU7Y0FBVyxJQUFWOzs7U0FFVFYsT0FBT2MsSUFBUCxFQUFhbUIsSUFBYixDQUFvQi9CLFdBQVE7UUFDOUJBLFFBQUtnQyxJQUFMLElBQWF4QixPQUFoQixFQUEwQjthQUFRLEtBQVA7O1dBQ3BCLElBQUlRLE9BQUosQ0FBYyxVQUFTUSxPQUFULEVBQWtCQyxNQUFsQixFQUEwQjt1QkFDNUJiLElBQWpCLEVBQ0djLElBREgsQ0FDVU8sWUFEVixFQUVHUCxJQUZILENBRVVRLGtCQUFvQkosT0FBcEIsQ0FGVixFQUdHRixFQUhILENBR1EsT0FIUixFQUdpQkgsTUFIakIsRUFJR0csRUFKSCxDQUlRLFFBSlIsRUFJa0IsTUFBTUosUUFBUSxJQUFSLENBSnhCO0tBREssQ0FBUDtHQUZLLENBQVA7Ozs7OyJ9
